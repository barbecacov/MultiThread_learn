（1）所谓静态库（*.a），就是程序link的时候就把静态库中的东西取出来，放到生成的可执行文件中，当这个可执行文件执行时，就不需要再次调用这个静态库了。

（2）所谓动态库（*.so），就是程序link的时候，只是将库中的 符号包含，并没有包含静态库里的内容，等到可执行程序在执行 

     时，需要依赖动态库中的内容，也就是“随用随取”。
     
（3）在linux编程中，对于静态库和动态库，在makefile中引用方式一模一样，只不过如果使用动态库，我们需要将动态库拷贝到目标系统中，比如拷贝到usr/lib下，然后可执行程序才能正常执行。
   
     而对于静态库，只要我们编译链接成功生成可执行文件，就不需要再目标系统中再拷贝了，因为可执行文件中已经包含了静态库的全部。 

 (4) 静态库和动态库的优缺点也是明显的，对于静态库，只要 编译链接成功，只需要将可执行文件放到目标板上，就可以直接执行，而不用再拷贝静态库了，一次性的，执行效率也更高 一些，
     
    缺点是当静态态库升级，则需要重新编译链接。而对于动态库，不仅需要将可执行文件拷贝到目标板上，还需要将动态库也拷贝到目标板上，缺点是执行速度相对慢一些。不过优点就是，当动态库升级时，我们只需要将动态库重新拷贝到目标板上，而 可执行程序并不需要 重新编译链接（前提是动态库接口不变）。

(5) int *a = new int(10); //动态创建整型数，无参数是 * a=0，有参数则 * a = 参数
(6) int *p = new int[10]; //创建一个有10个元素的动态整型数组，没有赋值，元素为随机数
(7) int *p = new int[10] (); //创建一个有10个元素的动态整型数组，并都赋值为0
